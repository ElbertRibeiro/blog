"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[60],{6218:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"docker-with-terraform","metadata":{"permalink":"/site/blog/docker-with-terraform","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-07-12-docker-with-terraform/index.md","source":"@site/blog/2024-07-12-docker-with-terraform/index.md","title":"Using Terraform with Docker","description":"What is Terraform?","date":"2024-07-12T00:00:00.000Z","formattedDate":"July 12, 2024","tags":[{"label":"docker","permalink":"/site/blog/tags/docker"},{"label":"terraform","permalink":"/site/blog/tags/terraform"},{"label":"IaC","permalink":"/site/blog/tags/ia-c"}],"readingTime":5.26,"hasTruncateMarker":false,"authors":[{"name":"Elbert Ribeiro","title":"Back End Engineer","url":"https://github.com/ElbertRibeiro","imageURL":"https://avatars.githubusercontent.com/u/45343415?v=4","key":"elbert"}],"frontMatter":{"slug":"docker-with-terraform","title":"Using Terraform with Docker","authors":["elbert"],"tags":["docker","terraform","IaC"]},"nextItem":{"title":"Spring Boot DDD Factory","permalink":"/site/blog/design-pattern-factory"}},"content":"## What is Terraform?\\n\\nAccording to the [IBM website](https://www.ibm.com/br-pt/topics/terraform), **Terraform** is an IaC (Infrastructure as\\nCode) tool that enables the creation, modification, and versioning of infrastructure safely and efficiently.\\n\\n## Using Terraform with Docker\\n\\nThis article aims to broaden the reader\'s horizons so that they can perceive the great utility that a tool like\\n**Terraform** has in the daily life of a developer and/or DevOps professional.\\n\\nIn this article, I will not address complex problems that the tool can solve. My goal here is to provide the reader with\\na first contact with the solution. Best practices and better usage will be topics addressed in future articles.\\n\\n## Technical Details\\n\\nThe source code generated in this article was created using a `Windowns 11 Amd64` machine, and the version of  \\n*Terraform* installed is `v1.9.2`.\\n\\n## How does Terraform work?\\n\\n1. Defining the Infrastructure:\\n   You write configuration files using Terraform\'s configuration language (HCL) or JSON. These files define the\\n   infrastructure resources you want to create, such as virtual machines, networks, and databases, along with their\\n   properties.\\n\\n2. Initialization:\\n   Before applying the configurations, you run ``terraform init``. This command initializes Terraform\'s working\\n   directory,\\n   downloads the necessary providers, and prepares the environment.\\n\\n3. Planning:\\n   With the ``terraform plan`` command, Terraform analyzes the configurations and generates an execution plan. The plan\\n   shows the changes that will be made to the infrastructure, so you can review them before applying.\\n\\n4. Application:\\n   After reviewing the plan, you execute ``terraform apply``. Terraform applies the changes according to the generated\\n   plan, creating, modifying, or deleting resources as needed.\\n\\n5. Management:\\n   Terraform maintains the state of your infrastructure in a state file. This file is used to track changes between the\\n   configuration and the real infrastructure, allowing Terraform to make incremental updates and maintain consistency.\\n\\n6. Destruction:\\n   When you need to remove the infrastructure, you can use the ``terraform destroy``command. This command removes all\\n   resources defined in your configurations.\\n\\n## Terraform Resources\\n\\nBelow I will list some of the resources of **Terraform**:\\n\\n1. `required_providers`:\\n    * Purpose: Specifies which providers are necessary for your Terraform configuration and which versions of these\\n      providers should be used.\\n    * Location: Usually found within the terraform block in a .tf file.\\n    * Components:\\n        * Source: Defines the provider\'s source (e.g., \\"hashicorp/aws\\").\\n        * Version: Defines the desired version of the provider (e.g., \\"~> 3.0\\").\\n    * Example:\\n      ```hcl\\n      terraform {\\n        required_providers {\\n          aws = {\\n            source  = \\"hashicorp/aws\\"\\n            version = \\"~> 3.0\\"\\n          }\\n        }\\n      }\\n      ```\\n\\n2. ``provider``:\\n    * Purpose: Configures and authenticates the infrastructure provider that Terraform will use to create and manage\\n      resources. The provider is responsible for interacting with external APIs.\\n    * Location: Defined in a provider block in a .tf file.\\n    * Components:\\n        * provider: Name of the provider (e.g., \\"aws\\").\\n        * region: Specific provider configuration (e.g., \\"us-west-1\\" for AWS).\\n    * Example:\\n      ````hcl\\n      provider \\"aws\\" {\\n      region = \\"us-west-1\\"\\n      }\\n      ````\\n\\n3. `resource`\\n    * Purpose: Defines a specific resource that you want to create, modify, or delete in your infrastructure. Resources\\n      are the main elements you manage with Terraform.\\n    * Location: Defined in a resource block in a .tf file.\\n    * Components:\\n        * resource: Type of resource and name (e.g., \\"aws_instance\\" \\"example\\").\\n        * ami: Specific property of the resource (e.g., AMI image ID for AWS).\\n        * instance_type: Another specific property (e.g., EC2 instance type).\\n    * Example:\\n      ````hcl\\n      resource \\"aws_instance\\" \\"example\\" {\\n      ami           = \\"ami-0c55b159cbfafe1f0\\"\\n      instance_type = \\"t2.micro\\"\\n      }\\n      ````\\n\\n### Summary of Relationships\\n\\nThe ``required_providers`` define which providers and their versions are necessary for the configuration, ensuring that\\nall necessary components are available and in the correct version.\\nThe ``provider`` configures how Terraform communicates with a specific provider (such as AWS, Azure, Google Cloud) and\\ndefines essential parameters for authentication and configuration.\\nThe ``resource`` block is where you define the specific details of the resources you want to create, manage, or delete\\nin your infrastructure.\\n\\n## Using Terraform with Docker\\n\\nNow let\'s talk about the main topic, which motivated the creation of this article.\\n\\nSince Terraform is a powerful tool for IaC, it is possible to create both complex and simple infrastructures (as in the\\nfollowing example).\\n\\nImagine you need to maintain a source code of an infrastructure. In this case, you could choose to use docker-compose\\nand use git for this purpose, but we know that for more complex cases, it may not be sufficient.\\n\\n### Docker Provider\\n\\nProviders are important resources when creating infrastructure. On\\nthe [Terraform website](https://registry.terraform.io/browse/providers), you can find several providers for the most\\npopular infrastructure providers.\\nTo create a Docker infrastructure, we will use the ``kreuzwerker/docker provider``, as shown in the example below:\\n\\n````terraform\\nterraform {\\n  required_providers {\\n    docker = {\\n      source  = \\"kreuzwerker/docker\\"\\n      version = \\"~> 2.15\\"\\n    }\\n  }\\n}\\n````\\n\\nTo use the local Docker, use the code below:\\n\\n````terraform\\n# Win11\\nprovider \\"docker\\" {\\n  host = \\"npipe:////./pipe/docker_engine\\"\\n}\\n````\\n\\n### Docker Resource\\n\\nJust like in a manual process, it is important to create the infrastructure sequentially and step by step. The first\\nthing to do in building a container is to pull the base image. To download an image using Terraform, simply use the\\n``resource`` below:\\n\\n````terraform\\n# Pulls the image\\nresource \\"docker_image\\" \\"ubuntu\\" {\\n  name = \\"ubuntu:latest\\"\\n}\\n````\\n\\n--------\\n\\nTo build the container, we will also use the ``resource``. As it is a container, our resource will contain some\\nadditional\\nproperties, such as container name and commands. However, it is important to define dependencies between the resources\\nso that they are executed in the correct order, as shown in the example below:\\n\\n````terraform\\n# Create a container\\nresource \\"docker_container\\" \\"teste_linux\\" {\\n  image = docker_image.ubuntu.image_id\\n  name  = \\"teste_linux\\"\\n  depends_on = [ docker_image.ubuntu ]\\n  command = [ \\"sleep\\", \\"infinity\\" ]\\n}\\n````\\n\\n--------\\n\\n## Conclusion\\n\\nFinally, we have our complete file below:\\n\\n```terraform\\n# main.tf\\n\\nterraform {\\n  required_providers {\\n    docker = {\\n      source  = \\"kreuzwerker/docker\\"\\n      version = \\"~> 2.15\\"\\n    }\\n  }\\n}\\n\\n# Win11\\nprovider \\"docker\\" {\\n  host = \\"npipe:////./pipe/docker_engine\\"\\n}\\n\\n\\n# Pulls the image\\nresource \\"docker_image\\" \\"ubuntu\\" {\\n  name = \\"ubuntu:latest\\"\\n}\\n\\n# Create a container\\nresource \\"docker_container\\" \\"teste_linux\\" {\\n  image = docker_image.ubuntu.image_id\\n  name  = \\"teste_linux\\"\\n  depends_on = [ docker_image.ubuntu ]\\n  command = [ \\"sleep\\", \\"infinity\\" ]\\n}\\n\\n```\\n\\nAs mentioned above, to execute the infrastructure, simply run the commands: ``terraform init`` and ``terraform apply``.\\n\\nOnce done, you will have your complete infrastructure based on Terraform."},{"id":"design-pattern-factory","metadata":{"permalink":"/site/blog/design-pattern-factory","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-11-07-design-pattern-factory/index.md","source":"@site/blog/2023-11-07-design-pattern-factory/index.md","title":"Spring Boot DDD Factory","description":"Design Patterns are solutions to common software development problems. They offer proven guidelines for designing code efficiently and in a reusable manner. Among these patterns, the Factory Pattern is widely used for creating objects in a flexible and decoupled way. In this article, we will explore how to apply the Factory Design Pattern in a Spring Boot project, providing a practical example to illustrate its usage.","date":"2023-11-07T00:00:00.000Z","formattedDate":"November 7, 2023","tags":[{"label":"spring-boot","permalink":"/site/blog/tags/spring-boot"},{"label":"java","permalink":"/site/blog/tags/java"},{"label":"ddd","permalink":"/site/blog/tags/ddd"},{"label":"design-pattern","permalink":"/site/blog/tags/design-pattern"}],"readingTime":2.96,"hasTruncateMarker":false,"authors":[{"name":"Elbert Ribeiro","title":"Back End Engineer","url":"https://github.com/ElbertRibeiro","imageURL":"https://avatars.githubusercontent.com/u/45343415?v=4","key":"elbert"}],"frontMatter":{"slug":"design-pattern-factory","title":"Spring Boot DDD Factory","authors":["elbert"],"tags":["spring-boot","java","ddd","design-pattern"]},"prevItem":{"title":"Using Terraform with Docker","permalink":"/site/blog/docker-with-terraform"},"nextItem":{"title":"Spring Boot DDD","permalink":"/site/blog/design-pattern"}},"content":"Design Patterns are solutions to common software development problems. They offer proven guidelines for designing code efficiently and in a reusable manner. Among these patterns, the Factory Pattern is widely used for creating objects in a flexible and decoupled way. In this article, we will explore how to apply the Factory Design Pattern in a Spring Boot project, providing a practical example to illustrate its usage.\\n\\n## The Factory Pattern\\n\\nThe Factory Pattern is a creational design pattern that focuses on object creation. It provides an interface for creating objects, allowing subclasses to decide which concrete class to instantiate. This promotes the principles of abstraction and decoupling.\\n\\nThere are two main variants of the Factory Pattern: the Factory Method and the Abstract Factory. However, we will focus on the Factory Method here, as it is the most commonly used and easiest to understand.\\n\\n## Implementing the Factory Method with Spring Boot\\n\\nLet\'s consider a scenario where we have an order management system in a Spring Boot application. There are different types of orders, such as physical product orders, service orders, and subscription orders. Each type of order requires different creation logic.\\n\\nTo apply the Factory Method, we will start by creating an `Order` interface that defines the common operations for all types of orders:\\n\\n```java\\npublic interface Order {\\n    void process();\\n}\\n```\\n\\nNow, we will create concrete implementations of this interface for each type of order:\\n\\n```java\\npublic class PhysicalProductOrder implements Order {\\n    @Override\\n    public void process() {\\n        // Logic to process a physical product order\\n    }\\n}\\n\\npublic class ServiceOrder implements Order {\\n    @Override\\n    public void process() {\\n        // Logic to process a service order\\n    }\\n}\\n\\npublic class SubscriptionOrder implements Order {\\n    @Override\\n    public void process() {\\n        // Logic to process a subscription order\\n    }\\n}\\n```\\n\\nNext, we will create the order factory that allows us to create concrete order instances:\\n\\n```java\\npublic class OrderFactory {\\n    public Order createOrder(OrderType type) {\\n        return switch (type) {\\n            case PHYSICAL_PRODUCT -> new PhysicalProductOrder();\\n            case SERVICE -> new ServiceOrder();\\n            case SUBSCRIPTION -> new SubscriptionOrder();\\n            default -> throw new IllegalArgumentException(\\"Unknown order type\\");\\n        };\\n    }\\n}\\n```\\n\\nThe `OrderType` enumeration is used to identify the type of order we want to create.\\n\\nNow, we can use the factory to create orders in our Spring Boot application:\\n\\n```java\\npublic class OrderService {\\n    private OrderFactory orderFactory;\\n\\n    public OrderService(OrderFactory orderFactory) {\\n        this.orderFactory = orderFactory;\\n    }\\n\\n    public void processOrder(OrderType type) {\\n        Order order = orderFactory.createOrder(type);\\n        order.process();\\n    }\\n}\\n```\\n\\nThe `OrderService` class injects the order factory and uses the Factory Method to create and process orders based on the specified type.\\n\\nFinally, we can configure Spring Boot to inject the order factory into our application:\\n\\n```java\\n@Configuration\\npublic class AppConfig {\\n    @Bean\\n    public OrderFactory orderFactory() {\\n        return new OrderFactory();\\n    }\\n}\\n```\\n\\nNow, whenever we need to create a new type of order, we can simply add a new implementation of the `Order` interface and update the order factory to accommodate the new type, keeping our code flexible and extensible.\\n\\n## Conclusion\\n\\nThe Factory Design Pattern is a valuable tool for creating objects in a flexible and decoupled manner in a Spring Boot project. It promotes the principles of abstraction and makes code more reusable and extensible. By following the principles of the Factory Method, we can create an order management system that can easily accommodate new types of orders without modifying existing code. This is just one example of how the Factory Design Pattern can be applied in software development, and its applications are broad and varied."},{"id":"design-pattern","metadata":{"permalink":"/site/blog/design-pattern","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-11-02-design-pattern/index.md","source":"@site/blog/2023-11-02-design-pattern/index.md","title":"Spring Boot DDD","description":"When developing a Spring Boot application, one of the most critical decisions to make is regarding the project\'s structure. Traditionally, many projects are organized into layers, such as DTO, Entity, and Service, to facilitate the separation of responsibilities. However, an alternative approach, based on domain-driven design (DDD), has gained prominence in recent years. In this article, we will explore the reasons why domain-based separation (e.g., Person, Car, Payment) is often a superior choice compared to layered separation.","date":"2023-11-02T00:00:00.000Z","formattedDate":"November 2, 2023","tags":[{"label":"spring-boot","permalink":"/site/blog/tags/spring-boot"},{"label":"java","permalink":"/site/blog/tags/java"},{"label":"ddd","permalink":"/site/blog/tags/ddd"},{"label":"design-pattern","permalink":"/site/blog/tags/design-pattern"}],"readingTime":3.43,"hasTruncateMarker":false,"authors":[{"name":"Elbert Ribeiro","title":"Back End Engineer","url":"https://github.com/ElbertRibeiro","imageURL":"https://avatars.githubusercontent.com/u/45343415?v=4","key":"elbert"}],"frontMatter":{"slug":"design-pattern","title":"Spring Boot DDD","authors":["elbert"],"tags":["spring-boot","java","ddd","design-pattern"]},"prevItem":{"title":"Spring Boot DDD Factory","permalink":"/site/blog/design-pattern-factory"},"nextItem":{"title":"Spring Boot With Weblogic","permalink":"/site/blog/spring-boot-with-weblogic"}},"content":"When developing a Spring Boot application, one of the most critical decisions to make is regarding the project\'s structure. Traditionally, many projects are organized into layers, such as DTO, Entity, and Service, to facilitate the separation of responsibilities. However, an alternative approach, based on domain-driven design (DDD), has gained prominence in recent years. In this article, we will explore the reasons why domain-based separation (e.g., Person, Car, Payment) is often a superior choice compared to layered separation.\\n\\n## **1. Clarity and Focus on Business Logic**\\n\\nThe domain-driven design approach places business logic at the heart of the project. Each package or module is associated with a specific domain concept, such as Person, Car, or Payment. This makes the code clearer as the components are closely related to business needs. As a result, developers can concentrate on the specific rules and functionalities of the domain, rather than getting lost in abstract layers.\\n\\n## **2. Ease of Maintenance and Evolution**\\n\\nThe domain-based structure simplifies the maintenance of the application. When a change is required in a business rule, you know exactly where to look and make the necessary modifications. In contrast, in a layered structure, changes often involve modifying several parts of the code, making it more error-prone and harder to maintain.\\n\\n## **3. Enhanced Code Reusability**\\n\\nWith domain-based separation, it is easier to reuse components in different parts of the application or even in future projects. For example, if you develop a Payment feature in one project, you can easily reuse it in another project involving Payments, without the need to recreate the entire service and data access layer.\\n\\n## **4. Improved Testability**\\n\\nThe domain-based structure allows the straightforward creation of domain-specific unit tests. This is crucial for ensuring code quality and application stability. Tests can be written more directly, covering the key domain functionalities.\\n\\n## **5. Scalability and Flexibility**\\n\\nAs the application grows, the domain-based structure naturally adapts. New functionalities can be added within the context of the existing domain, as long as the domain is well defined. This flexibility makes it easier to scale the application as new requirements emerge.\\n\\n## **Downsides of Layered Organization**\\n\\nTo provide a comprehensive overview, it\'s essential to consider the downsides of a layered organization:\\n\\n1. **Complex Communication**: A rigid separation into layers can lead to complex communication between the layers, resulting in intricate code to transfer data between different layers, such as DTOs.\\n\\n2. **Risk of Anemic Domain**: In projects with a layered organization, the so-called \\"Anemic Domain\\" can occur, where entities (Entities) frequently lack behavior (methods), resulting in an excessively burdened service layer.\\n\\n3. **Increased Boilerplate Code**: With distinct layers, it often requires writing more boilerplate code to convert data between DTOs and Entities, increasing code complexity.\\n\\n4. **Difficulty Maintaining Cohesion**: Maintaining class and component cohesion can be challenging in projects with layered organization, as responsibilities are distributed across different parts of the code.\\n\\n5. **Reduced Clarity of Business Rules**: In a layered structure, business logic is often diluted, making it difficult to understand specific business rules.\\n\\n## **Bibliographic References**\\n\\nTo further your understanding of the domain-driven design approach in Spring Boot projects and the disadvantages of a layered organization, you may consider reading the following books:\\n\\n1. \\"Domain-Driven Design: Tackling Complexity in the Heart of Software\\" by Eric Evans\\n2. \\"Implementing Domain-Driven Design\\" by Vaughn Vernon\\n3. \\"Patterns, Principles, and Practices of Domain-Driven Design\\" by Scott Millett and Nick Tune\\n4. \\"Clean Code: A Handbook of Agile Software Craftsmanship\\" by Robert C. Martin\\n5. \\"Refactoring: Improving the Design of Existing Code\\" by Martin Fowler\\n\\nThese references provide valuable insights into code organization and best practices for Spring Boot projects.\\n\\n## **Conclusion**\\n\\nThe domain-driven design approach offers numerous advantages over layered separation in Spring Boot projects, including greater clarity, ease of maintenance, code reusability, testability, and scalability. However, it\'s important to note that the choice between these approaches should be based on the specific project\'s needs and the development team\'s preferences. In some cases, a combination of both approaches may be the ideal solution, allowing you to leverage the best of each approach to effectively meet project requirements."},{"id":"spring-boot-with-weblogic","metadata":{"permalink":"/site/blog/spring-boot-with-weblogic","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-05-27-spring-boot-with-weblogic/index.md","source":"@site/blog/2023-05-27-spring-boot-with-weblogic/index.md","title":"Spring Boot With Weblogic","description":"This article was born out of a day-to-day need, in short, at my workplace we are updating the infrastructure and some","date":"2023-05-27T00:00:00.000Z","formattedDate":"May 27, 2023","tags":[{"label":"spring-boot","permalink":"/site/blog/tags/spring-boot"},{"label":"java","permalink":"/site/blog/tags/java"},{"label":"weblogic","permalink":"/site/blog/tags/weblogic"}],"readingTime":6.905,"hasTruncateMarker":false,"authors":[{"name":"Elbert Ribeiro","title":"Back End Engineer","url":"https://github.com/ElbertRibeiro","imageURL":"https://avatars.githubusercontent.com/u/45343415?v=4","key":"elbert"}],"frontMatter":{"slug":"spring-boot-with-weblogic","title":"Spring Boot With Weblogic","authors":["elbert"],"tags":["spring-boot","java","weblogic"]},"prevItem":{"title":"Spring Boot DDD","permalink":"/site/blog/design-pattern"},"nextItem":{"title":"What is Gitpod?","permalink":"/site/blog/what-is-gitpod"}},"content":"This article was born out of a day-to-day need, in short, at my workplace we are updating the infrastructure and some\\ntechnologies (which is beside the point now), but the problem is; we have more than 200 applications in production, how\\nto make all this run with spring-boot and in weblogic 12? (The idea here is to make the transition of technologies\\nlittle by little).\\n\\nMany of the materials I\u2019ve found on the internet are either outdated or simply don\u2019t work for spring-boot 2.7.12 and\\nweblogic 12.2.1.3, or are simply too complicated for a novice developer to understand. The idea here is not to explain\\neach point of the configuration, class or lib, how it is done and how it works. The idea is that any dev, inciting or\\nnot, can replicate the configuration, and have your application running with weblogic + spring-boot.\\n\\nThe structure I used in the project applies a concept of maven multi modules (if you are a beginner developer and don\u2019t\\nknow what I\u2019m talking about, talk to your senior dev or search the internet about the advantages and disadvantages.\\nMaybe I\u2019ll write an article about). Even using maven multi modules it is a simple structure, with 30 min studying the\\ncode you will understand. For this article I used Intellij Community, although it has the Ultimate version, I want to\\nkeep this article as generic as possible so that any dev can apply what was developed here in their reality.\\n\\n----\\n\\n### Project Structure\\n\\nAbout the structure of the project, I developed two modules, api and core.\\n\\n![spring-boot-projetc-struture](img/spring-boot-projetc-struture.png)\\n\\n----\\n\\n### Main Module\\n\\nLet\u2019s start with the parent project\u2019s pom.xml. The idea here is to group the default settings for every project. I\u2019m\\nusing Java 8 and UTF-8 for the encoder, however, whether your project is legacy or not, it may have another encoder (\\ncheck before compiling, especially if your project is JSP).\\n\\n````maven\\n<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n<project xmlns:xsi=\\"http://www.w3.org/2001/XMLSchema-instance\\" \\n         xmlns=\\"http://maven.apache.org/POM/4.0.0\\"\\n         xsi:schemaLocation=\\"http://maven.apache.org/POM/4.0.0 \\n         https://maven.apache.org/xsd/maven-4.0.0.xsd\\">\\n    <modelVersion>4.0.0</modelVersion>\\n    <groupId>com.elbertribeiro</groupId>\\n    <artifactId>spring-boot-weblogic</artifactId>\\n    <version>0.0.1-SNAPSHOT</version>\\n    <name>spring-boot-weblogic</name>\\n    <modules>\\n        <module>spring-boot-weblogic-core</module>\\n        <module>spring-boot-weblogic-api</module>\\n    </modules>\\n    <packaging>pom</packaging>\\n    <properties>\\n        <java.version>1.8</java.version>\\n        <spring.boot.version>2.7.12</spring.boot.version>\\n        <maven.compiler.source>8</maven.compiler.source>\\n        <maven.compiler.target>8</maven.compiler.target>\\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\\n    </properties>\\n</project>\\n````\\n\\n----\\n\\n### Core Module\\n\\nNow, going from bottom to top, in the spring-boot-weblogic-core module, we have the following structure:\\n\\n![core-module-structure](img/core-module-structure.png)\\n\\nIn spring-boot-weblogic-core\u2019s pom.xml we will have:\\n\\n````maven\\n<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n<project xmlns:xsi=\\"http://www.w3.org/2001/XMLSchema-instance\\"\\n         xmlns=\\"http://maven.apache.org/POM/4.0.0\\"\\n         xsi:schemaLocation=\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\">\\n    <modelVersion>4.0.0</modelVersion>\\n    <parent>\\n        <groupId>com.elbertribeiro</groupId>\\n        <artifactId>spring-boot-weblogic</artifactId>\\n        <version>0.0.1-SNAPSHOT</version>\\n    </parent>\\n\\n    <artifactId>spring-boot-weblogic-core</artifactId>\\n    <dependencies>\\n        \x3c!--SPRING BOOT--\x3e\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n            <version>${spring.boot.version}</version>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n            <version>${spring.boot.version}</version>\\n            <scope>test</scope>\\n        </dependency>\\n    </dependencies>\\n</project>\\n````\\n\\nNote that the pom.xml is simple, and the idea is that it contains the dependencies for the api module.\\n\\nInside the JAVA directory we have only one package (as the idea here is just to present a functional concept, this model\\nis as simple as possible).\\n\\n![teste-service](img/teste-service.png)\\n\\nIn the test package we have the TesteService class, which would work as a Service layer for the api. In TesteService, we\\nhave the following code;\\n\\n````java\\npackage com.elbertribeiro.teste;\\n\\nimport org.springframework.stereotype.Service;\\n\\n@Service\\npublic class TesteService {\\n    public String retornoService() {\\n        return \\"Teste Weblogic com multiModules e service e @Autowired\\";\\n    }\\n}\\n````\\n\\nNote that the added dependency in spring-boot-weblogic-core\u2019s pom.xml allows us to use Annotations normally. The core\\nmodule is simple for the purpose of this article, now let\u2019s move on to the more interesting part.\\n\\n### API module\\n\\nNow, let\u2019s go to the spring-boot-weblogic-api module, we have the following structure:\\n\\n![spring-boot-project-structure](img/spring-boot-project-structure.png)\\n\\nThe first point to note is that the api module has more files, because it will contain the class that initializes the\\nproject in spring-boot and will also be implemented in weblogic.\\n\\nIn the spring-boot-weblogic-api pom.xml we will have:\\n\\n````maven\\n<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n<project xmlns:xsi=\\"http://www.w3.org/2001/XMLSchema-instance\\" \\n         xmlns=\\"http://maven.apache.org/POM/4.0.0\\"\\n         xsi:schemaLocation=\\"http://maven.apache.org/POM/4.0.0 \\n         https://maven.apache.org/xsd/maven-4.0.0.xsd\\">\\n    <modelVersion>4.0.0</modelVersion>\\n    <parent>\\n        <groupId>com.elbertribeiro</groupId>\\n        <artifactId>spring-boot-weblogic</artifactId>\\n        <version>0.0.1-SNAPSHOT</version>\\n    </parent>\\n\\n    <artifactId>spring-boot-weblogic-api</artifactId>\\n    <packaging>war</packaging>\\n\\n    <dependencies>\\n        \x3c!-- Dependencia dos modulos --\x3e\\n        <dependency>\\n            <groupId>${project.parent.groupId}</groupId>\\n            <artifactId>${project.parent.artifactId}-core</artifactId>\\n            <version>${project.parent.version}</version>\\n        </dependency>\\n\\n        \x3c!--SPRING BOOT--\x3e\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-tomcat</artifactId>\\n            <version>${spring.boot.version}</version>\\n            <scope>provided</scope>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-devtools</artifactId>\\n            <version>${spring.boot.version}</version>\\n            <scope>runtime</scope>\\n            <optional>true</optional>\\n        </dependency>\\n    </dependencies>\\n\\n    <build>\\n        <plugins>\\n            <plugin>\\n                <groupId>org.springframework.boot</groupId>\\n                <artifactId>spring-boot-maven-plugin</artifactId>\\n                <version>${spring.boot.version}</version>\\n            </plugin>\\n            <plugin>\\n                <groupId>org.apache.maven.plugins</groupId>\\n                <artifactId>maven-war-plugin</artifactId>\\n                <version>3.3.2</version>\\n                <configuration>\\n                    <webResources>\\n                        <resource>\\n                            <directory>src/main/webapp</directory>\\n                        </resource>\\n                    </webResources>\\n                </configuration>\\n            </plugin>\\n        </plugins>\\n    </build>\\n</project>\\n````\\n\\nIf you paid attention to the parent module, you noticed that the spring-boot versions were defined globally and the\\nmodules only refer to the specified version.\\n\\nThe most important dependency here is:\\n\\n![core-module-structure](img/core-module-structure.png)\\n\\nIt will be responsible for allowing us to use the project with spring-boot even adding configurations to run in\\nweblogic.\\n\\nAlso note that we have the core module of the project as a dependency, allowing access to any class, method or entity\\nadded in the core module:\\n\\n![module-core-dependency](img/module-core-dependency.png)\\n\\nWe also have devtoos as a dependency, for those who don\u2019t know it\u2019s a lib that allows a browser update when a resource\\nis changed at compile time, removing the need to restart your spring-boot service.\\n\\n![devtools-dependency](img/devtools-dependency.png)\\n\\nIf you looked at the spring-boot-weblogic-api pom.xml you might have noticed two plugins:\\n\\n![plugin.png](img/plugin.png)\\n\\nThe first allows you to run spring-boot commands like mvn spring-boot:run, while the second plugin is responsible for\\ncollecting and compiling all dependencies, classes and resources of the web application into a web application file,\\ngenerating an artifact of type *.war.\\n\\nI understand that I said I wouldn\u2019t explain every lib configuration point and operation, but understanding how the\\ndependencies work and when they will be used is important, this prevents your system from evolving by applying\\nresponsibilities where it shouldn\u2019t.\\n\\nNow let\u2019s go to the \u201cinteresting part\u201d, let\u2019s add some configurations for the application to run in weblogic, however, I\\nrecommend that you research how each configuration works and why it exists. With that, I hope to partially fulfill the\\npromise of not explaining how libs and configurations work (we can write an article explaining how they work soon).\\n\\nAbout the resources directory, we only have an empty *.yml properties file. Already in the webapp directory, we have the\\nfiles that allow you to add your application to weblogic, for the structure of the packages we have:\\n\\n![weblogic.png](img/weblogic.png)\\n\\nIn the weblogic.xml file we have;\\n\\n````maven\\n<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n<wls:weblogic-web-app\\n        xmlns:wls=\\"http://xmlns.oracle.com/weblogic/weblogic-web-app\\"\\n        xmlns:xsi=\\"http://www.w3.org/2001/XMLSchema-instance\\"\\n        xsi:schemaLocation=\\"http://xmlns.oracle.com/weblogic/weblogic-web-app\\n        http://xmlns.oracle.com/weblogic/weblogic-web-app/1.4/weblogic-web-app.xsd\\">\\n\\n    <wls:context-root>spring-boot-weblogic</wls:context-root>\\n    <wls:container-descriptor>\\n        <wls:prefer-application-packages>\\n            <wls:package-name>org.slf4j.*</wls:package-name>\\n            <wls:package-name>org.springframework.*</wls:package-name>\\n        </wls:prefer-application-packages>\\n    </wls:container-descriptor>\\n</wls:weblogic-web-app>\\n````\\n\\nIn the webapp directory we also have the file dispatcherServlet-servlet.xml;\\n\\n````maven\\n<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n<beans xmlns=\\"http://www.springframework.org/schema/beans\\"\\n       xmlns:xsi=\\"http://www.w3.org/2001/XMLSchema-instance\\"\\n       xsi:schemaLocation=\\"http://www.springframework.org/schema/beans\\n    http://www.springframework.org/schema/beans/spring-beans.xsd\\">\\n\\n</beans>\\n````\\n\\nAnd finally, we have the file structure of the JAVA directory:\\n\\n![dispatcherServlet-servlet.png](img/dispatcherServlet-servlet.png)\\n\\nWhere the ServletInitializer class has only one method:\\n\\n````java\\npackage com.elbertribeiro.configuracao;\\n\\nimport org.springframework.boot.builder.SpringApplicationBuilder;\\nimport org.springframework.boot.web.servlet.support.SpringBootServletInitializer;\\n\\npublic class ServletInitializer extends SpringBootServletInitializer {\\n\\n    @Override\\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\\n        return application.sources(SpringBootWeblogicApplication.class);\\n    }\\n\\n}\\n````\\n\\nThe configure method is used to configure the spring-boot application to add to an external application server such as\\nweblogic. It takes a SpringApplicationBuilder object as a parameter and returns an instance of it.\\n\\nThe configure method is being replaced to configure the SpringBootWeblogicApplication application as the spring-boot\\napplication source. This means that the SpringApplicationBuilder is being configured to load the configuration and\\ncomponents of that specific application when deploying to weblogic.\\n\\nAnd we also have the class contains the main method, responsible for initializing our spring-boot application.\\n\\n````java\\npackage com.elbertribeiro.configuracao;\\n\\nimport org.springframework.boot.SpringApplication;\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\nimport org.springframework.context.annotation.ComponentScan;\\n\\n@SpringBootApplication\\n@ComponentScan(basePackages = \\"com.elbertribeiro\\")\\npublic class SpringBootWeblogicApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(SpringBootWeblogicApplication.class, args);\\n    }\\n\\n}\\n````\\n\\nAnd as resources, we have only one endpoint that is present in the TesteController class;\\n\\n````java\\npackage com.elbertribeiro.controller;\\n\\nimport com.elbertribeiro.teste.TesteService;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.web.bind.annotation.GetMapping;\\nimport org.springframework.web.bind.annotation.RequestMapping;\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n@RestController\\n@RequestMapping(\\"teste\\")\\npublic class TesteController {\\n    @Autowired\\n    private TesteService service;\\n\\n    @GetMapping\\n    public String getTest() {\\n        return service.retornoService();\\n    }\\n}\\n````\\n\\nI hope the article didn\u2019t get too long, before finalizing it lacks proof that all this works \ud83d\ude02.\\n\\n----\\n\\n### Running the application with spring-boot\\n\\nTo run this project with spring-boot run the command below in the spring-boot-weblogic-api module\\n\\n````maven\\nmvn spring-boot:run\\n````\\n\\n![test-spring-boot.png](img/test-spring-boot.png)\\n\\n### Running the application with Weblogic\\n\\nUpload the artifact to weblogic and access the weblogic address with the path of your application.\\n\\n![test-weblogic.png](img/test-weblogic.png)\\n\\n### Conclusion\\n\\nWell, it is true that using a multi-module maven project may not seem interesting at first, but it helps a lot,\\nespecially when we are talking about scalable software, if necessary, you can delete the core module, just pass the\\ndependency to the module api move our classes to the api module as well.\\n\\nThe code for the developed project is here: https://github.com/ElbertRibeiro/spring-boot-weblogic/tree/artigo-medium\\n\\nBelow I will put my social networks, feel free to comment or discuss any topic addressed in this project.\\n\\n### References\\n\\n* https://www.baeldung.com/maven-generate-war-file\\n\\n* https://o7planning.org/11901/deploy-spring-boot-application-on-oracle-weblogic-server"},{"id":"what-is-gitpod","metadata":{"permalink":"/site/blog/what-is-gitpod","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-04-19-what-is-gitpod/index.md","source":"@site/blog/2023-04-19-what-is-gitpod/index.md","title":"What is Gitpod?","description":"Docusaurus Plushie","date":"2023-04-19T00:00:00.000Z","formattedDate":"April 19, 2023","tags":[{"label":"gitpod","permalink":"/site/blog/tags/gitpod"},{"label":"github","permalink":"/site/blog/tags/github"},{"label":"gitlab","permalink":"/site/blog/tags/gitlab"},{"label":"code-editor","permalink":"/site/blog/tags/code-editor"}],"readingTime":1.065,"hasTruncateMarker":false,"authors":[{"name":"Elbert Ribeiro","title":"Back End Engineer","url":"https://github.com/ElbertRibeiro","imageURL":"https://avatars.githubusercontent.com/u/45343415?v=4","key":"elbert"}],"frontMatter":{"slug":"what-is-gitpod","title":"What is Gitpod?","authors":["elbert"],"tags":["gitpod","github","gitlab","code-editor"]},"prevItem":{"title":"Spring Boot With Weblogic","permalink":"/site/blog/spring-boot-with-weblogic"},"nextItem":{"title":"How to configure ssh key on github?","permalink":"/site/blog/configure-ssh-key"}},"content":"![Docusaurus Plushie](./imagem-gitpod.png)\\n\\nAs a developer, whether you\u2019re a beginner or a senior, you\u2019ve probably come across the following situation: in a certain\\nproject, you\u2019ve set up all the necessary dependencies and development environment for the project, but you\u2019re not alone\\nin this task. There are two more people in the project with you, but they can\u2019t or take too long to set up the\\nenvironment, either due to package incompatibilities with the chosen language or differences between operating systems.\\nThat\u2019s where Gitpod comes in, a tool that some developers still don\u2019t know about.\\n\\nWhat is Gitpod?\\n\\nIt is a cloud-based development environment, but unlike other environments, you create a workspace with all the\\nnecessary installations and configurations, including the use of the terminal.\\n\\nHow does it work?\\n\\nBy logging in with your GitHub account at https://www.gitpod.io/, you automatically have access to your repositories, or\\neven third-party repositories. Following the instructions on gitpod.io, a browser tab is opened for environment\\nconfiguration, and from there, you just code. You can create complete project structures, local servers with Node.js or\\nDjango, and many other things.\\n\\nWhat is it used for?\\n\\nIn addition to being able to share the workspace with anyone, avoiding the stress of setting up the environment and\\nfocusing only on coding the project."},{"id":"configure-ssh-key","metadata":{"permalink":"/site/blog/configure-ssh-key","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-01-09-configure-ssh-key/index.md","source":"@site/blog/2023-01-09-configure-ssh-key/index.md","title":"How to configure ssh key on github?","description":"Checking Generated Keys","date":"2023-01-09T00:00:00.000Z","formattedDate":"January 9, 2023","tags":[{"label":"github","permalink":"/site/blog/tags/github"},{"label":"gitlab","permalink":"/site/blog/tags/gitlab"},{"label":"code-editor","permalink":"/site/blog/tags/code-editor"},{"label":"ssh","permalink":"/site/blog/tags/ssh"}],"readingTime":0.91,"hasTruncateMarker":false,"authors":[{"name":"Elbert Ribeiro","title":"Back End Engineer","url":"https://github.com/ElbertRibeiro","imageURL":"https://avatars.githubusercontent.com/u/45343415?v=4","key":"elbert"}],"frontMatter":{"slug":"configure-ssh-key","title":"How to configure ssh key on github?","authors":["elbert"],"tags":["github","gitlab","code-editor","ssh"]},"prevItem":{"title":"What is Gitpod?","permalink":"/site/blog/what-is-gitpod"}},"content":"## Checking Generated Keys\\n\\nTo list the existing keys, execute the command: `ls -al ~/.ssh`\\n\\n## Generating SSH Key\\n\\nOpen the **git bash** or your Linux terminal and run the following command:\\n\\n```shell\\nssh-keygen -t ed25519 -C \\"your_email@example.com\\"\\n```\\n\\n> Note\xb9: Replace \\"your_email@example.com\\" with your actual email.\\n\\n## Copying the Generated Key\\n\\nTo copy the generated key to the clipboard, use the command:\\n\\n```shell\\ncat ~/.ssh/id_ed25519.pub. \\n```\\n\\n## Adding Key to GitHub\\n\\nOpen GitHub and go to the profile icon > Settings in the top right corner. In the user settings sidebar, click on \\"SSH\\nand GPG keys.\\" Click on the \\"New SSH key\\" button. In the \\"Title\\" field, add a descriptive label for the new key. For\\nexample, if you are using your personal computer, you can name this key \\"Personal Computer.\\" Paste the public key from\\nthe clipboard into the \\"Key\\" field. Click on \\"Add SSH key,\\" and you\'re done!\\n\\n## Testing Connection\\n\\nExecute the following command in the terminal:\\n\\n```shell\\nssh -T git@github.com\\n```\\n\\n> Note\xb2: After executing the previous command, type \\"yes\\" in the interactive git bash terminal."}]}')}}]);